use std::{collections::HashSet, sync::Arc};

use internment::ArcIntern;
use itertools::Itertools;
use puzzle_theory::{
    numbers::Int,
    permutations::{Algorithm, Permutation, PermutationGroup},
    union_find::{SetInfo, UnionFind},
};

use crate::architectures::{
    CycleGenerator, CycleGeneratorSubcycle,
    length_of_substring_that_this_string_is_n_repeated_copies_of,
};

struct FaceletSources(HashSet<usize>);

impl SetInfo for FaceletSources {
    fn merge(&mut self, new_child: Self) {
        self.0.extend(new_child.0);
    }
}

/// Calculate the orbits of all of the facelets along with which algorithms contribute to the orbit
fn find_orbits<'a>(
    facelet_count: usize,
    permutations: impl Iterator<Item = &'a Permutation> + Clone,
) -> UnionFind<FaceletSources, ()> {
    // Initialize the union-find
    let mut sets = vec![];

    for facelet in 0..facelet_count {
        // For each facelet, find which algorithms move it and add them to the set
        let mut contains_facelets_from = HashSet::new();

        for (i, permutation) in permutations.clone().enumerate() {
            if permutation.mapping().get(facelet) != facelet {
                contains_facelets_from.insert(i);
            }
        }

        sets.push(FaceletSources(contains_facelets_from));
    }

    let mut union_find = UnionFind::new_with_initial_set_info(sets.into_iter());

    // Union all facelets that share the same orbit
    for permutation in permutations {
        for (from, to) in permutation.mapping().all_changes() {
            // They have the same orbit if one is mapped to the other
            union_find.union(from, to, ());
        }
    }

    union_find
}

/// Convert the algorithms into a list of cycle generators and a list of shared facelets
///
/// # Errors
///
/// If either of the algorithms have an invalid generator, the function will compose all of the generators before it and return the name of the generator that doesn't exist as an error
pub fn algorithms_to_cycle_generators(
    group: &Arc<PermutationGroup>,
    algorithms: Box<[Algorithm]>,
) -> (Vec<CycleGenerator>, Vec<usize>) {
    // Find the orbits of all of the facelets in the subgroup generated by `permutations`
    let orbits = find_orbits(
        group.facelet_count(),
        algorithms.iter().map(|v| v.permutation()),
    );

    let mut shared_facelets = vec![];

    (
        algorithms
            .into_iter()
            .map(|algorithm| {
                // Dump all unshared facelets out of the union-find into a list and all shared facelets into the shared_facelets list
                let mut unshared_cycles = vec![];

                for cycle in algorithm.permutation().cycles() {
                    if orbits.find(cycle[0]).set_meta().0.len() > 1 {
                        shared_facelets.extend_from_slice(cycle);
                        continue;
                    }

                    let chromatic_order =
                        length_of_substring_that_this_string_is_n_repeated_copies_of(
                            cycle.iter().map(|&idx| &*group.facelet_colors()[idx]),
                        );

                    if chromatic_order == 1 {
                        continue;
                    }

                    unshared_cycles.push(CycleGeneratorSubcycle {
                        facelet_cycle: cycle.to_owned(),
                        chromatic_order: Int::from(chromatic_order),
                    });
                }

                CycleGenerator::new(algorithm, unshared_cycles)
            })
            .collect(),
        shared_facelets.into_iter().unique().collect_vec(),
    )
}

#[cfg(test)]
mod tests {
    use std::{collections::HashMap, sync::Arc};

    use internment::ArcIntern;
    use puzzle_theory::{
        numbers::Int,
        permutations::{Algorithm, Permutation, PermutationGroup},
    };

    use crate::architectures::{Architecture, CycleGeneratorSubcycle};

    #[test]
    fn simple() {
        let mut generators = HashMap::new();

        generators.insert(
            ArcIntern::from("A"),
            Permutation::from_cycles(vec![vec![0, 1, 2]]),
        );
        generators.insert(
            ArcIntern::from("B"),
            Permutation::from_cycles(vec![vec![3, 4, 5]]),
        );
        generators.insert(
            ArcIntern::from("C"),
            Permutation::from_cycles(vec![vec![5, 6, 7]]),
        );
        generators.insert(
            ArcIntern::from("D"),
            Permutation::from_cycles(vec![vec![8, 9]]),
        );
        generators.insert(
            ArcIntern::from("E"),
            Permutation::from_cycles(vec![vec![10, 11, 12, 13]]),
        );
        generators.insert(
            ArcIntern::from("A'"),
            Permutation::from_cycles(vec![vec![2, 1, 0]]),
        );
        generators.insert(
            ArcIntern::from("B'"),
            Permutation::from_cycles(vec![vec![5, 4, 3]]),
        );
        generators.insert(
            ArcIntern::from("C'"),
            Permutation::from_cycles(vec![vec![7, 6, 5]]),
        );
        generators.insert(
            ArcIntern::from("E'"),
            Permutation::from_cycles(vec![vec![13, 12, 11, 10]]),
        );

        let perm_group = Arc::new(PermutationGroup::new(
            vec![
                ArcIntern::from("A"),
                ArcIntern::from("B"),
                ArcIntern::from("C"),
                ArcIntern::from("D"),
                ArcIntern::from("E"),
                ArcIntern::from("F"),
                ArcIntern::from("G"),
                ArcIntern::from("H"),
                ArcIntern::from("I"),
                ArcIntern::from("J"),
                ArcIntern::from("K"),
                ArcIntern::from("L"),
                ArcIntern::from("K"),
                ArcIntern::from("L"),
            ],
            vec![ArcIntern::from("A"); 14],
            generators,
        ));

        let preset = Architecture::new(
            Arc::clone(&perm_group),
            Box::new([
                Algorithm::parse_from_string(Arc::clone(&perm_group), "A B").unwrap(),
                Algorithm::parse_from_string(Arc::clone(&perm_group), "C D E").unwrap(),
            ]),
        );

        for i in 3..=7 {
            assert!(preset.shared_facelets().contains(&i));
        }

        assert_eq!(preset.registers()[0].order(), Int::from(3));
        assert_eq!(
            preset.registers()[0].unshared_cycles(),
            vec![CycleGeneratorSubcycle {
                facelet_cycle: vec![0, 1, 2],
                chromatic_order: Int::from(3_usize),
            }]
        );
        assert_eq!(preset.registers()[1].order(), Int::from(2));
        assert_eq!(
            preset.registers()[1].unshared_cycles(),
            vec![
                CycleGeneratorSubcycle {
                    facelet_cycle: vec![8, 9],
                    chromatic_order: Int::from(2_usize)
                },
                CycleGeneratorSubcycle {
                    facelet_cycle: vec![10, 11, 12, 13],
                    chromatic_order: Int::from(2_usize)
                }
            ]
        );
    }
}
