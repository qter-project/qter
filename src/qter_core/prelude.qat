.start-rhai
    fn validate_equals_order(r1, r2, r3) {
        let o1 = r1.order();
        let o2 = r2.order();
        let o3 = r3.order();
        if o1 != o2 || o1 != o3 {
            throw `Expected the orders of ${r1}, ${r2}, and ${r3} to be equal. Got orders of ${o1}, ${o2}, {o3}.`;
        }

        return ();
    }

    fn subtract_order_relative(r1, n) {
        return [ [ "add", r1, (-n) % r1.order() ] ];
    }
end-rhai

.macro sub {
    ($R:reg $N:int) => rhai subtract_order_relative($R, $N)
}

.macro inc {
    ($R:reg) => add $R 1
}

.macro dec {
    ($R:reg) => sub $R 1
}

.macro move {
    ($R1:reg to $R2:reg) => {
        zero_loop:
            solved-goto $R1 move_done
            dec $R1
            inc $R2
            goto zero_loop
        move_done:
    }
}

.macro set {
    ($R1:reg to $R2:reg) => {
        set $R1 to 0
        move $R2 to $R1
    }

    ($R:reg to $N:int) => {
        zero_loop:
            solved-goto $R move_done
            dec $R
            goto zero_loop
        move_done:
            add $R $N
    }
}

.macro if {
    (solved $R:reg $code:block) => {
            solved-goto $R do_if
            goto after_if
        do_if:
            $code
        after_if:
    }
    (not-solved $R:reg $code:block) => {
            solved-goto $R after_if
            $code
        after_if:
    }
    (solved $R:reg $code1:block else $code2:block) => {
        if not-solved $R {
            $code2
        } else {
            $code1
        }
    }
    (not-solved $R:reg $code1:block else $code2:block) => {
            if not-solved $R {
                $code1
                goto over_else
            }
            $code2
        over_else:
    }
    (equals $R:reg $N:int $code:block) => {
        if equals $R $N {
            $code
        } else {}
    }
    (not-equals $R:reg $N:int $code:block) => {
        if not-equals $R $N {
            $code
        } else {}
    }
    (equals $R:reg $N:int $code1:block else $code2:block) => {
        if not-equals $R $N {
            $code2
        } else {
            $code1
        }
    }
    (not-equals $R:reg $N:int $code1:block else $code2:block) => {
        sub $R $N
        if not-solved $R {
            add $R $N
            $code2
        } else {
            add $R $N
            $code1
        }
    }
    (equals $R1:reg $R2:reg using $R3:reg $code:block) => {
            rhai validate_equals_order($R1, $R2, $R3)
            set $R3 to 0
        equals_loop:
            solved-goto $R1 first_zero
            solved-goto $R2 fail_loop
            dec $R1
            dec $R2
            inc $R3
            goto equals_loop
        first_zero:
            solved-goto $R2 success_loop
        fail_loop:
            solved-goto $R3 fail
            inc $R1
            inc $R2
            dec $R3
            goto fail_loop
        success_loop:
            solved-goto $R3 success
            inc $R1
            inc $R2
            dec $R3
            goto success_loop
        success:
            $code
        fail:
    }
    (not-equals $R1:reg $R2:reg using $R3:reg $code:block) => {
            rhai validate_equals_order($R1, $R2, $R3)
            set $R3 to 0
        equals_loop:
            solved-goto $R1 first_zero
            solved-goto $R2 fail_loop
            dec $R1
            dec $R2
            inc $R3
            goto equals_loop
        first_zero:
            solved-goto $R2 success_loop
        fail_loop:
            solved-goto $R3 fail
            inc $R1
            inc $R2
            dec $R3
            goto fail_loop
        success_loop:
            solved-goto $R3 success
            inc $R1
            inc $R2
            dec $R3
            goto success_loop
        // Only change is to swap these two labels
        fail:
            $code
        success:
    }
    (equals $R1:reg $R2:reg using $R3:reg $code1:block else $code2:block) => {
            if equals $R1 $R2 using $R3 {
                $code1
                goto over_else
            }
            $code2
        over_else:
    }
    (not-equals $R1:reg $R2:reg using $R3:reg $code1:block else $code2:block) => {
        if equals $R1 $R2 using $R3 {
            $code2
        } else {
            $code1
        }
    }
}

.macro loop {
    ($code:block) => {
        !continue:
            $code
            goto continue
        !break:
    }
}

.macro while {
    (solved $R:reg $code:block) => {
            goto continue
        do_iteration:
            $code
        !continue:
            solved-goto $R do_iteration
        !break:
    }
    (not-solved $R:reg $code:block) => {
        !continue:
            solved-goto $R break
            $code
            goto continue
        !break:
    }
    (equals $R:reg $N:int $code:block) => {
        loop {
            if not-equals $R $N {
                goto break
            }
            $code
        }
    }
    (not-equals $R:reg $N:int $code:block) => {
        loop {
            if equals $R $N {
                goto break
            }
            $code
        }
    }
    (equals $R1:reg $R2:reg using $R3:reg $code:block) => {
        loop {
            if not-equals $R1 $R2 using $R3 {
                goto break
            }
            $code
        }
    }
    (not-equals $R1:reg $R2:reg using $R3:reg $code:block) => {
        loop {
            if equals $R1 $R2 using $R3 {
                goto break
            }
            $code
        }
    }
}

.start-rhai
    fn repeat(code, start, end) {
        repeat(code, start, end, ())
    }

    fn repeat(code, start, end, name) {
        let output = [];

        for i in range(start, end) {
            if name != () {
                output.push([ ".define", `\$${name}`, i ]);
            }
            output.extend(code);
        }

        return output;
    }
end-rhai

.macro repeat {
    ($times:int $code:block) => rhai repeat_($code, 1, $times)

    ($times:int $var:ident $code:block) => rhai repeat_($code, 1, $times, $var)

    // should parse nested for loops such as `repeat j from $i to 10 { ... }`
    // because the outer $i should be evaluated first
    ($var:ident from $start:int to $end:int $code:block) => {
        rhai repeat_($code, $start, $end, $var)
    }
}

.start-rhai
    fn multiply(r1, r2, r3) {
        validate_same_orders(r1, r2, r3);
        // TODO: Implement multiplication. Result in register r1, nullify r2/r3

        throw "Three register multiplication is unimplemented";
    }
end-rhai

.macro multiply {
    ($R1:reg $R2:reg using $R3:reg) => {
        rhai multiply($R1, $R2, $R3)
    }
    ($R1:reg $N:int at $R2:reg) => {
        multiply_loop:
            solved-goto $R1 multiply_done
            add $R2 N
            dec $R1
            goto multiply_loop
        multiply_done:
    }
}

